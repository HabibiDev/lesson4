text ="Python поддерживает динамическую типизацию, то есть тип переменной определяется только во время исполнения. Поэтому вместо «присваивания значения переменной» лучше говорить о «связывании значения с некоторым именем». В Python имеются встроенные типы: булевый, строка, Unicode-строка, целое число произвольной точности, число с плавающей запятой, комплексное число и некоторые другие. Из коллекций в Python встроены: список, кортеж (неизменяемый список), словарь, множество и другие[26]. Все значения являются объектами, в том числе функции, методы, модули, классы. Добавить новый тип можно либо написав класс (class), либо определив новый тип в модуле расширения (например, написанном на языке C). Система классов поддерживает наследование (одиночное и множественное) и метапрограммирование. Возможно наследование от большинства встроенных типов и типов расширений. Все объекты делятся на ссылочные и атомарные. К атомарным относятся int, long (в версии 3 любое число int, так как в версии 3 нет ограничения на размер), complex и некоторые другие. При присваивании атомарных объектов копируется их значение, в то время как для ссылочных копируется только указатель на объект, таким образом, обе переменные после присваивания используют одно и то же значение. Ссылочные объекты бывают изменяемые и неизменяемые. Например, строки и кортежи являются неизменяемыми, а списки, словари и многие другие объекты — изменяемыми. Кортеж в Python является, по сути, неизменяемым списком. Во многих случаях кортежи работают быстрее списков[27], поэтому если вы не планируете изменять последовательность, то лучше использовать именно их. "
new_text = text.upper()

words = new_text.split()
new_words = []
for word in words:
    word = word.replace(',', '')\
               .replace('.', '')\
               .replace(' ', '')\
               .replace('«', '')\
               .replace('(', '')\
               .replace(')', '')\
               .replace('»', '')\
               .replace(':', '')
    new_words.append(word)
max_count = 0
population_word = ''
for word in new_words:
    if max_count < new_words.count(word):
        max_count = new_words.count(word)
        population_word = word

print(max_count, population_word)